export function createGapiMock(setWindowProp = 'gapi') {
    let nextInteraction;
    const _user = {
        isSignedIn: false,
        scopes: [],
        props: {
            id: undefined,
            name: '',
            givenName: '',
            familyName: '',
            imageUrl: '',
            email: '',
        },
        resolveNextInteraction: () => {
            if (typeof (nextInteraction) === 'function') {
                nextInteraction();
                nextInteraction = undefined;
            }
            else if (!nextInteraction) {
                nextInteraction = Promise.resolve();
            }
        },
    };
    const user = {
        isSignedIn: (scopes = [], userProps = {}) => {
            var _a, _b;
            _user.isSignedIn = true,
                _user.scopes = scopes;
            _user.props = Object.assign(Object.assign(Object.assign({}, _user.props), userProps), { id: (_b = (_a = userProps.id) !== null && _a !== void 0 ? _a : _user.props.id) !== null && _b !== void 0 ? _b : mockId() });
        },
        isNotSignedIn: (scopes = [], userProps) => {
            _user.isSignedIn = false,
                _user.scopes = scopes;
            _user.props = Object.assign(Object.assign({}, _user.props), userProps);
        },
        nextInteraction: () => {
            if (!nextInteraction) {
                return new Promise(res => { nextInteraction = res; });
            }
            else if (nextInteraction instanceof Promise) {
                const p = nextInteraction;
                nextInteraction = undefined;
                return p;
            }
            throw 'user.nextInteraction() was called multiple times before an interaction happened.\n'
                + 'This was probably not intended.';
        },
    };
    const _discoveryDocs = {};
    const registerDiscoveryDocs = o => Object.keys(o).forEach(k => _discoveryDocs[k] = o[k]);
    const _modules = {
        auth2: createAuthModuleMock,
        client: createClientModuleMock,
    };
    const registerModuleMocks = o => Object.keys(o).forEach(k => _modules[k] = o[k]);
    const gapi = {
        load: (modules, then) => {
            Promise.all(modules.split(':').map(k => new Promise((res) => {
                res();
                if (!gapi[k]) {
                    gapi[k] = _modules[k]
                        ? _modules[k]({ gapi, user, _user, _discoveryDocs })
                        : (name) => ({
                            init: () => notImplemented(`Mock for gapi module "${name}"`),
                        });
                }
                res();
            }))).then(typeof then === 'function' ? then : then.callback);
        },
    };
    if (setWindowProp) {
        window[setWindowProp] = gapi;
    }
    return { gapi, user, registerModuleMocks, registerDiscoveryDocs };
}
function mockId() {
    return Math.random().toString(10).substr(2, 10);
}
function notImplemented(descr) {
    return `${descr} is not implemented yet.`;
}
function createAuthModuleMock({ user, _user }) {
    let initConfig;
    let authInstance;
    const auth2 = {
        init: (config) => {
            const { client_id, fetch_basic_profile = true, scope = '', } = config;
            if (!client_id) {
                throw { message: `Missing required parameter 'client_id'` };
            }
            else if (!fetch_basic_profile && !scope) {
                throw { message: `Missing required parameter 'scope'` };
            }
            if (!initConfig) {
                initConfig = { client_id, fetch_basic_profile, scope };
            }
            else if (client_id !== initConfig.client_id || fetch_basic_profile !== initConfig.fetch_basic_profile || scope !== initConfig.scope) {
                throw { message: 'gapi.auth2 has been initialized with different options. Consider calling gapi.auth2.getAuthInstance() instead of gapi.auth2.init().' };
            }
            if (!authInstance) {
                const effectiveScope = fetch_basic_profile ? scope + ' openid email profile' : scope;
                authInstance = createAuthInstanceMock(fetch_basic_profile, effectiveScope);
            }
            return authInstance;
        },
        getAuthInstance: () => authInstance,
        authorize: () => { throw notImplemented('auth2.authorize'); },
        enableDebugLogs: () => { throw notImplemented('auth2.enableDebugLogs'); },
    };
    function createAuthInstanceMock(fetch_basic_profile, initScope) {
        let currentUser;
        const isSignedInListeners = [];
        const currentUserListeners = [];
        const auth = {
            then: (onInit, onFailure) => {
                Promise.resolve().then(() => onInit(auth), (r) => onFailure(r));
            },
            signIn: ({ scope = '', prompt = undefined } = {}) => {
                const scopeArray = (initScope !== null && initScope !== void 0 ? initScope : '' + ' ' + scope).split(' ').filter(k => Boolean(k));
                return requestScopes(scopeArray, prompt);
            },
            signOut: () => new Promise(res => {
                const isSignedInChanged = _user.isSignedIn;
                _user.isSignedIn = false;
                currentUser = createCurrentUserMock();
                res(currentUser);
                notifyListeners(isSignedInChanged);
            }),
            disconnect: () => new Promise(res => {
                _user.scopes = [];
                auth.signOut().then(() => res());
            }),
            currentUser: {
                // currentUser.get() can return undefined on newly initialized GoogleAuth
                get: () => currentUser,
                listen: (c) => { currentUserListeners.push(c); },
            },
            isSignedIn: {
                get: () => _user.isSignedIn,
                listen: (c) => { isSignedInListeners.push(c); },
            },
            grantOfflineAccess: () => { throw notImplemented('GoogleAuth.grantOfflineAccess'); },
            attachClickHandler: () => { throw notImplemented('GoogleAuth.attachClickHandler'); },
        };
        if (_user.isSignedIn) {
            currentUser = createCurrentUserMock();
        }
        return auth;
        function notifyListeners(isSignedInChanged) {
            if (isSignedInChanged) {
                isSignedInListeners.forEach(c => c(_user.isSignedIn));
            }
            currentUserListeners.forEach(c => currentUser && c(currentUser));
        }
        function requestScopes(scopes, prompt) {
            if (_user.promise) {
                throw 'The behavior when a previous Promise is still pending is unknown - call user.grantsScopes() or user.closesPopup()';
            }
            return _user.promise = new Promise((res, rej) => {
                function clearInteraction() {
                    delete user.grantsScopes;
                    delete user.closesPopup;
                    Promise.resolve().then(() => { delete _user.promise; });
                }
                user.grantsScopes = (grantedScopes = true, userProps = {}) => {
                    var _a, _b;
                    const isSignedInChanged = !_user.isSignedIn;
                    _user.isSignedIn = true;
                    if (grantedScopes === true) {
                        grantedScopes = scopes;
                    }
                    // openid is always added
                    grantedScopes.push('openid');
                    grantedScopes.forEach(k => {
                        if (!_user.scopes.includes(k)) {
                            _user.scopes.push(k);
                        }
                        // the module adds these scopes automatically
                        if (k === 'profile' && !_user.scopes.includes('https://www.googleapis.com/auth/userinfo.profile')) {
                            _user.scopes.push('https://www.googleapis.com/auth/userinfo.profile');
                        }
                        else if (k === 'email' && !_user.scopes.includes('https://www.googleapis.com/auth/userinfo.email')) {
                            _user.scopes.push('https://www.googleapis.com/auth/userinfo.email');
                        }
                    });
                    _user.props = Object.assign(Object.assign(Object.assign({}, _user.props), userProps), { id: (_b = (_a = userProps === null || userProps === void 0 ? void 0 : userProps.id) !== null && _a !== void 0 ? _a : _user.props.id) !== null && _b !== void 0 ? _b : mockId() });
                    currentUser = createCurrentUserMock();
                    clearInteraction();
                    res(currentUser);
                    notifyListeners(isSignedInChanged);
                };
                user.deniesAccess = () => {
                    clearInteraction();
                    rej({ error: 'access_denied' });
                };
                user.closesPopup = () => {
                    clearInteraction();
                    rej({ error: 'popup_closed_by_user' });
                };
                if (scopes.every(k => _user.scopes.includes(k))) {
                    // if a user granted scopes before, the popup closes automatically
                    if (_user.isSignedIn && prompt && !['consent', 'select_account'].includes(prompt)) {
                        user.grantsScopes();
                    }
                }
                else if (prompt === 'none') {
                    rej({ error_subtype: 'access_denied', error: 'immediate_failed' });
                }
                _user.resolveNextInteraction();
            });
        }
        function createCurrentUserMock() {
            const basicProfile = createBasicProfileMock();
            return {
                getId: () => { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                signIn: (options) => authInstance === null || authInstance === void 0 ? void 0 : authInstance.signIn(options),
                isSignedIn: () => _user.isSignedIn,
                getHostedDomain: () => { throw notImplemented('GoogleUser.getHostedDomain'); },
                getGrantedScopes: () => _user.isSignedIn
                    // when fetch_basic_profile is true, the user can not login without consenting to these scopes
                    ? _user.scopes.concat(fetch_basic_profile ? ['email', 'openid', 'profile'] : []).join(' ')
                    : '',
                getBasicProfile: () => basicProfile,
                getAuthResponse: () => { throw notImplemented('GoogleUser.getHostedDomain'); },
                reloadAuthResponse: () => { throw notImplemented('GoogleUser.getHostedDomain'); },
                hasGrantedScopes: (scope) => scope.split(' ').filter(k => Boolean(k) && !_user.scopes.includes(k)).length > 0,
                grant: (options = {}) => authInstance && authInstance.signIn(options),
                grantOfflineAccess: () => { throw notImplemented('GoogleUser.getHostedDomain'); },
                disconnect: () => authInstance && authInstance.disconnect(),
            };
            function createBasicProfileMock() {
                return (initConfig === null || initConfig === void 0 ? void 0 : initConfig.fetch_basic_profile) ? {
                    getId: () => { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                    getName: () => { var _a; return (_a = _user.props.name) !== null && _a !== void 0 ? _a : ''; },
                    getGivenName: () => { var _a; return (_a = _user.props.givenName) !== null && _a !== void 0 ? _a : ''; },
                    getFamilyName: () => { var _a; return (_a = _user.props.familyName) !== null && _a !== void 0 ? _a : ''; },
                    getImageUrl: () => { var _a; return (_a = _user.props.imageUrl) !== null && _a !== void 0 ? _a : ''; },
                    getEmail: () => { var _a; return (_a = _user.props.email) !== null && _a !== void 0 ? _a : ''; },
                }
                    : {
                        getId: () => { var _a; return (_a = _user.props.id) !== null && _a !== void 0 ? _a : ''; },
                        getName: () => '',
                        getGivenName: () => '',
                        getFamilyName: () => '',
                        getImageUrl: () => '',
                        getEmail: () => '',
                    };
            }
        }
    }
    return auth2;
}
function createClientModuleMock({ gapi, _discoveryDocs }) {
    const client = {
        init: ({ clientId = undefined, scope = undefined, discoveryDocs = [] }) => new Promise((res, rej) => {
            const p = [];
            if (scope) {
                if (gapi.auth2) {
                    p.push(gapi.auth2.init({ client_id: clientId, scope }));
                }
                else {
                    throw 'gapi.auth2 not loaded';
                }
            }
            p.push(...discoveryDocs.map(k => new Promise((res, rej) => {
                try {
                    if (typeof (_discoveryDocs[k]) === 'function') {
                        _discoveryDocs[k](gapi);
                    }
                    else {
                        throw `Tried to load discoveryDocs ${k} - use registerDiscoveryDocs to mock discoveryDocs`;
                    }
                    res();
                }
                catch (e) {
                    rej(e);
                }
            })));
            Promise.all(p).then(() => res(), () => rej());
        }),
    };
    return client;
}
